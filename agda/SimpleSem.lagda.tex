\begin{code}
{-# OPTIONS --safe --without-K --postfix-projections #-}
module SimpleSem where

open import Data.LTree
open import Data.LTree.Vector
open import Data.Product
open import Function.Base using (id)
open import Relation.Binary.PropositionalEquality hiding ([_])

infix 4 _∋_ _⊢_
infixr 5 _`→_
infix 5 _++ᶜ_

data Ty : Set where
  ι : Ty
  _`→_ : (A B : Ty) → Ty
\end{code}

%<*Ctx>
\begin{code}
record Ctx : Set where
  constructor ctx
  field
    {shape} : LTree
    ty-ctx : Vector Ty shape
open Ctx public
\end{code}
%</Ctx>

\begin{code}
[_]ᶜ : Ty → Ctx
[ A ]ᶜ = ctx [ A ]
[]ᶜ : Ctx
[]ᶜ = ctx []
_++ᶜ_ : (Γ Δ : Ctx) → Ctx
ctx γ ++ᶜ ctx δ = ctx (γ ++ δ)
\end{code}

%<*Var>
\begin{code}
record _∋_ (Γ : Ctx) (A : Ty) : Set where
  constructor el
  field
    idx : Ptr (Γ .shape)
    tyq : Γ .ty-ctx idx ≡ A
open _∋_ public
\end{code}
%</Var>

\begin{code}
hereᵛ : ∀ {A} → [ A ]ᶜ ∋ A
hereᵛ = el here refl
↙ᵛ : ∀ {Γ Δ A} → Γ ∋ A → Γ ++ᶜ Δ ∋ A
↙ᵛ (el i q) = el (↙ i) q
↘ᵛ : ∀ {Γ Δ A} → Δ ∋ A → Γ ++ᶜ Δ ∋ A
↘ᵛ (el i q) = el (↘ i) q
\end{code}

%<*Term>
\begin{code}
data _⊢_ (Γ : Ctx) : Ty → Set where
  var : ∀ {A} → Γ ∋ A → Γ ⊢ A
  app : ∀ {A B} → Γ ⊢ A `→ B → Γ ⊢ A → Γ ⊢ B
  lam : ∀ {A B} → Γ ++ᶜ [ A ]ᶜ ⊢ B → Γ ⊢ A `→ B
\end{code}
%</Term>

\begin{code}
module Kits where
\end{code}

%<*Env>
\begin{code}
  Env : (K : Ctx → Ty → Set) (Γ Δ : Ctx) → Set
  Env K Γ Δ = ∀ {A} → Δ ∋ A → K Γ A
\end{code}
%</Env>

%<*RenSub>
\begin{code}
  Ren = Env _∋_
  Sub = Env _⊢_
\end{code}
%</RenSub>

\begin{code}
  □ : (Ctx → Set) → (Ctx → Set)
  □ T Γ = ∀ {Γ⁺} → Ren Γ⁺ Γ → T Γ⁺

  ○ : (Ctx → Set) → (Ctx → Set)
  ○ T Γ = ∀ {Δ} → T (Γ ++ᶜ Δ)
\end{code}

%<*Kit>
\begin{code}
  record Semantics (𝓥 𝓒 : Ctx → Ty → Set) : Set where
    constructor kit
    field
      ↙ᵏ : ∀ {Γ Δ A} → 𝓥 Γ A → 𝓥 (Γ ++ᶜ Δ) A
      ⟦var⟧ : ∀ {Γ A} → 𝓥 Γ A → 𝓒 Γ A
      ⟦app⟧ : ∀ {Γ A B} → 𝓒 Γ (A `→ B) → 𝓒 Γ A → 𝓒 Γ B
      ⟦lam⟧ : ∀ {Γ A B} → ○ (λ Γ⁺ → 𝓥 Γ⁺ A → 𝓒 Γ⁺ B) Γ → 𝓒 Γ (A `→ B)
\end{code}
%</Kit>

N.B., without the □, we can write \verb|sem| without \verb|bindEnv|.
\begin{code}
    bindEnv : ∀ {Γ Δ Γr Δr} →
      Env 𝓥 Γ Δ → Env 𝓥 (Γ ++ᶜ Γr) Δr → Env 𝓥 (Γ ++ᶜ Γr) (Δ ++ᶜ Δr)
    bindEnv ρ σ (el (↙ i) q) = ↙ᵏ (ρ (el i q))
    bindEnv ρ σ (el (↘ i) q) = σ (el i q)

    sem : ∀ {Γ Δ A} → Env 𝓥 Γ Δ → Δ ⊢ A → 𝓒 Γ A
    sem ρ (var x) = ⟦var⟧ (ρ x)
    sem ρ (app M N) = ⟦app⟧ (sem ρ M) (sem ρ N)
    sem ρ (lam M) = ⟦lam⟧ (λ v → sem (bindEnv ρ (λ { (el i refl) → v })) M)

  module _ where
    open Semantics

    RenSem : Semantics _∋_ _⊢_
    RenSem .↙ᵏ = ↙ᵛ
    RenSem .⟦var⟧ = var
    RenSem .⟦app⟧ = app
    RenSem .⟦lam⟧ b = lam (b (↘ᵛ hereᵛ))  -- (b ↙ᵛ (↘ᵛ hereᵛ))

    ren = sem RenSem

    -- SubSem : Semantics _⊢_ _⊢_
    -- SubSem .↙ᵏ = {!!}
    -- SubSem .⟦var⟧ = id
    -- SubSem .⟦app⟧ = app
    -- SubSem .⟦lam⟧ b = lam (b ↙ᵛ (var (↘ᵛ hereᵛ)))
\end{code}
