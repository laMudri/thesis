\begin{code}
{-# OPTIONS --without-K --sized-types --postfix-projections #-}

open import Algebra.Po
open import Level

module Snippets (Ty : Set) (poSemiring : PoSemiring 0ℓ 0ℓ 0ℓ) where

open import Generic.Linear.Everything Ty poSemiring

open import Function.Extra
open import Relation.Binary.PropositionalEquality as ≡ using (_≡_)
open import Size

s0 : ∀ {v c} (𝓥 : OpenFam v) (𝓒 : OpenFam c) → ExtOpenFam _
s0 𝓥 𝓒 Δ Γ A =
\end{code}
%<*KripkeVCDGA>
\begin{code}[inline]
  Kripke 𝓥 𝓒 Δ Γ A
\end{code}
%</KripkeVCDGA>
\begin{code}
s1 : ∀ {v c} (𝓥 : OpenFam v) (𝓒 : OpenFam c)
  (s₁ sₙ : Ann) (B₁ Bₙ : Ty) (⋯ : OpenType 0ℓ) (Γ : Ctx) (A : Ty) → _
s1 𝓥 𝓒 s₁ sₙ B₁ Bₙ ⋯ Γ A =
\end{code}
%<*KripkeExpanded>
\begin{code}[inline]
  □ʳ (s₁ ·ᶜ [ 𝓥 ]_⊨ B₁ ─✴ᶜ ⋯ ─✴ᶜ sₙ ·ᶜ [ 𝓥 ]_⊨ Bₙ ─✴ᶜ [ 𝓒 ]_⊨ A) Γ
\end{code}
%</KripkeExpanded>
\begin{code}
s2 : System → Size → (Γ Δ : Ctx) → Ty → Set
s2 d sz Γ Δ A =
\end{code}
%<*term-with-bound>
\begin{code}[inline]
  [ d , sz ] Γ ++ᶜ Δ ⊢ A
\end{code}
%</term-with-bound>
\begin{code}
_ : (Γ Θ : Ctx) → Ctx
_ = λ Γ Θ →
\end{code}
%<*GT>
\begin{code}[inline]
  Γ ++ᶜ Θ
\end{code}
%</GT>
\begin{code}
_ : ∀ {a b r} {A : Set a} {B : Set b} (R : A → B → Set r) x y →
\end{code}
%<*Rxy-R>
\begin{code}[inline]
  R x y ≡ R _ _
\end{code}
%</Rxy-R>
\begin{code}
_ = λ R x y → ≡.refl
\end{code}
