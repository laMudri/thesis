\begin{code}
{-# OPTIONS --without-K --sized-types --postfix-projections #-}

open import Algebra.Po
open import Level

module Snippets (Ty : Set) (poSemiring : PoSemiring 0ℓ 0ℓ 0ℓ) where

open import Generic.Linear.Everything Ty poSemiring

open import Data.LTree
open import Data.LTree.Vector
open import Data.Product
open import Function.Extra
open import Relation.Binary.PropositionalEquality as ≡ using (_≡_)
open import Size

s0 : ∀ {v c} (𝓥 : OpenFam v) (𝓒 : OpenFam c) → ExtOpenFam _
s0 𝓥 𝓒 Δ Γ A =
\end{code}
%<*KripkeVCDGA>
\begin{code}[inline]
  Kripke 𝓥 𝓒 Δ Γ A
\end{code}
%</KripkeVCDGA>
\begin{code}
s1 : ∀ {v c} (𝓥 : OpenFam v) (𝓒 : OpenFam c)
  (s₁ sₙ : Ann) (B₁ Bₙ : Ty) (⋯ : OpenType 0ℓ) (Γ : Ctx) (A : Ty) → _
s1 𝓥 𝓒 s₁ sₙ B₁ Bₙ ⋯ Γ A =
\end{code}
%<*KripkeExpanded>
\begin{code}[inline]
  □ʳ (s₁ ·ᶜ [ 𝓥 ]_⊨ B₁ ─✴ᶜ ⋯ ─✴ᶜ sₙ ·ᶜ [ 𝓥 ]_⊨ Bₙ ─✴ᶜ [ 𝓒 ]_⊨ A) Γ
\end{code}
%</KripkeExpanded>
\begin{code}
s2 : System → Size → (Γ Δ : Ctx) → Ty → Set
s2 d sz Γ Δ A =
\end{code}
%<*term-with-bound>
\begin{code}[inline]
  [ d , sz ] Γ ++ᶜ Δ ⊢ A
\end{code}
%</term-with-bound>
\begin{code}
_ : (Γ Θ : Ctx) → Ctx
_ = λ Γ Θ →
\end{code}
%<*GT>
\begin{code}[inline]
  Γ ++ᶜ Θ
\end{code}
%</GT>
\begin{code}
_ : ∀ {a b r} {A : Set a} {B : Set b} (R : A → B → Set r) x y →
\end{code}
%<*Rxy-R>
\begin{code}[inline]
  R x y ≡ R _ _
\end{code}
%</Rxy-R>
\begin{code}
_ = λ R x y → ≡.refl
\end{code}
\begin{code}
_ : ∀ {ℓ s t} → LinFuncRel s t ℓ → Vector Ann s → Vector Ann t → _
_ = λ Ψ P Q →
\end{code}
%<*Psi-rel-P-Q>
\begin{code}[inline]
  Ψ .rel P Q
\end{code}
%</Psi-rel-P-Q>
\begin{code}
s3 : ∀ {v} (𝓥 : OpenFam v) (Γ Δ : Ctx) _ → _
s3 𝓥 Γ Δ A =
\end{code}
%<*GvDashA>
\begin{code}[inline]
  [ 𝓥 ] Γ ⊨ A
\end{code}
%</GvDashA>
\begin{code}
  ,′
\end{code}
%<*GenvD>
\begin{code}[inline]
  [ 𝓥 ] Γ ⇒ᵉ Δ
\end{code}
%</GenvD>
