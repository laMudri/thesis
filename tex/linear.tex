\chapter{Linearity and modality}\label{sec:linearity}

The techniques of \cref{sec:simple} were developed to handle idealised core
calculi, like the simply typed $\lambda$-calculus and its many variants.
Such core calculi can be seen as simplified models of real programming languages
and/or their intermediate representations.
A potential programming language feature --- required for many desired semantics
but only relatively recently appearing in programming languages --- that is not
handled by the techniques of \cref{sec:simple} is restrictions on how variables
can be used.
In the simple type systems covered in \cref{sec:simple}, the only restriction on
the use of a variable is that it is used as an expression of the appropriate
type.
However, we could also consider having somehow ``guarded'' subexpressions in
which some variables bound outside cannot occur, or systems in which the use of
a variable in one part of an expression precludes its use in another part of
that expression (the variable having been ``used up'').
I will introduce and motivate some such systems in this chapter, and argue that
they are impossible to capture directly in the framework presented in
\cref{sec:gen-syn}.

Languages and systems implementing features inspired by linear logic include
Rust~\citep{MK14,Rust}, ATS~\citep{Xi04,ZX05}, and various implementations of
session types~\citep{HLVCCDMPRTVTZ16}.
Additionally, forms of linearity have been used in theoretical work, for example
to bound computational complexity~\citep{GSS92,Hofmann03} or to write programs
which support incremental updates to computations~\citep{ER03,Ehrhard18}.
As for modality, \citet{IMO20} show that common data-flow analyses for
imperative languages can be recast as modal type systems, though such analyses
have generally been developed in an ad hoc fashion.
Such a recasting may be useful to understand the metatheoretic properties of
programs passing such static analyses.
More user-facing implementations of modal type systems include the system for
stack allocation in OCaml~\citep{DW22} and the approach to programmer-annotated
erasure found in Agda and Idris~\citep{Atkey18}.

In this chapter, I look at two standard type-theoretic features that motivate
considering calculi going beyond simple type theories as delineated in
\cref{sec:simple} or equivalently by \citet{AACMM21}.
The first feature is a $\Box$-modality --- specifically, the $\Box$-modality of
intuitionistic S4, which I discuss in \cref{sec:modal}.
The second feature is linearity, which I discuss in \cref{sec:ill}.
In particular, I discuss possible syntaxes for each, with a mind to
being able to apply the techniques described in \cref{sec:simple}.
After having introduced these topics, I finish this chapter with a survey of
prior work on representing such type theories in proof assistants in
\cref{sec:linmech}.

\section{Intuitionistic S4 modal logic}\label{sec:modal}
\input{modal.tex}

\section{Intuitionistic Linear Logic}\label{sec:ill}
\input{ill.tex}

\section{Mechanisations and systematisations of substructural logics}
\label{sec:linmech}
\input{linmech.tex}
