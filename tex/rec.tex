The bunched connectives give us a means by which to quickly design and
experiment with new type systems.
We will see in \cref{sec:framework} that all such syntaxes are well behaved to
the extend that they all support the appropriate notion of substitution, which
again expedites experimentation.
In this section, I give some example syntactic features that can be covered in
the bunched connective paradigm.

\subsection{Alternative object-language connectives}\label{sec:alt}

I presented $\name$ as an essentially arbitrary collection of rules, with no
broader characterisation than that it intuitively seems to capture some notion
of ``usage'' and that it supports the semantics I give in \cref{sec:den-sem}.
Therefore, in this subsection I give some examples of variant syntaxes others,
with different use cases, may be interested in.
In particular, I give a variant of function types where usage annotations go
``on the arrow'', and a variant of tensor products with a stronger elimination
rule.

We can produce an annotated function arrow connective by combining parts of the
rules for the unannotated function arrow $\multimap$ with parts of the rules for
the modal operator $\oc$.

\begin{mathpar}
  \ebrule[comb]{%
    \hypo{\gr rA \vdash B}
    \infer1[$\gr r\multimap$-I]{\vdash \gr rA \multimap B}
  }
  \and
  \ebrule[comb]{%
    \hypo{\vdash \gr rA \multimap B}
    \hypo{\sep}
    \hypo{\gr r \cdot \plr{\vdash A}}
    \infer3[$\gr r\multimap$-E]{\vdash B}
  }
\end{mathpar}

We can also give an alternative elimination rule for $\otimes$-products, as
found in Granule~\citep{Granule18,HMWO21} and the work of
\citet{AbelBernardy2020} and \citet{reed10distance}.
This modified rule allows us to, for example, have a variable
$\gr rx : A \otimes B$ for any $\gr r$, and pattern-match it into
$\gr ry : A, \gr rz : B$.
With the standard $\name$ rule from \cref{fig:lr}, the newly bound variables are
always given annotation $\gr 1$, and we would only be able to do the match in
the first place if $\gr r$ were coercible to (i.e.\ less than or equal to)
$\gr1$.
The alternative rule below is not compatible with linear logic, because it
allows us to derive
$\oc\gr r\plr{A \otimes B} \multimap \oc\gr rA \otimes \oc\gr r B$
parametric in $\gr r$, $A$, and $B$.
In particular, with the linearity semiring of \cref{def:lin-semiring}, we get
$\oc\gr\omega\plr{A \otimes B} \multimap \oc\gr\omega A \otimes \oc\gr\omega B$,
corresponding to the ordinary linear logic formula
$\oc\plr{A \otimes B} \multimap \oc A \otimes \oc B$, which is not provable.

\begin{mathpar}
  \ebrule[comb]{%
    \hypo{\gr r \cdot \plr{\vdash A \otimes B}}
    \hypo{\sep}
    \hypo{\gr rA, \gr rB \vdash C}
    \infer3[$\otimes$-E$'$]{\vdash C}
  }
\end{mathpar}

\subsection{Adding inductive types and recursion}\label{sec:rec}

Based on an intuitive understanding of ``usage'', recursion introduces a new
phenomenon relative to the forms of programs we have seen so far:
Terms can be used an unbounded number of times.
For example, notice the following reduction in Agda.

\ExecuteMetaData[\SnippetsTwotex]{sum-reduction}

The function \AgdaFunction{\_+\_} has been copied into 3 different places in
the running of the program.
This copying is despite no type telling us that \AgdaFunction{\_+\_} would be
used 3 times (both \verb|[1,2,3]| and \verb|[2,3]| have type
\AgdaDatatype{List}\AgdaSpace{}\AgdaDatatype{$\mathbb N$}, despite the
corresponding folds using \AgdaFunction{\_+\_} a different number of times).
As such, when checking an application of \AgdaFunction{foldr}, we need check
that we can use its functional argument (\AgdaFunction{\_+\_} in this case) an
arbitrary number of times.
If we were to fix $\Ann$ as the $\{\gr0, \gr1, \gr\omega\}$ posemiring, then
wrapping the type of the functional argument in $\oc\gr\omega$ would suffice.
However, we want to remain generic in the choice of semiring.

The following additions to \name{} support a broad class of
inductive types.
I define strictly positive functors syntactically, with the only notable
restrictions relative to the syntax of types with a type variable $X$
being not being allowed to use $X$ in the domain of a function type or within a
$\oc$-type.
I then add least fixed points of such strictly positive functors to the syntax
of types.

\begin{align*}
  U &\Coloneqq A \multimap (-) \\
  {\odot} &\Coloneqq {\otimes} \mid {\oplus} \mid {\with} \\
  F[X], G[X] &\Coloneqq X \mid A \mid U(F[X]) \mid F[X] \odot G[X] \\
  A &\Coloneqq \cdots \mid \mu X.~F[X]
\end{align*}

\begin{example}
  We may define $\mathrm{List}_A \coloneqq \mu X.~I \oplus \plr{A \otimes X}$.
\end{example}

One could also consider supporting mutually inductive types, but I do not in
this thesis for the sake of simplicity.

In the typing rules, introduction of an inductive type is standard.
For the elimination rule, we follow a similar pattern to other pattern-matching
rules --- $\oplus$-E, $\otimes$-E, and $\oc$-E --- by splitting the context
and typing the eliminand in one half ($\grP$).
We type the continuation in the other half, but because the continuation may
be used multiple times, and in a modal context, we require that $\grQ$ is
preserved by all linear operations.

\begin{displaymath}
  \begin{prooftree}
    \hypo{\grR\gamma \vdash F[\mu X.~F[X]]}
    \infer1[$\mu$-I]{\grR\gamma \vdash \mu X.~F[X]}
  \end{prooftree}
\end{displaymath}
\begin{displaymath}
  \begin{prooftree}
    \hypo{\grR \leq \grP + \grQ}
    \hypo{\grP\gamma \vdash \mu X.~F[X]}
    \hypo{%
      \begin{matrix*}[l]
        \grQ \leq \gr0 \\
        \grQ \leq \grQ + \grQ
      \end{matrix*}%
    }
    \hypo{\grQ\gamma, \gr1F[C] \vdash C}
    \infer4[$\mu$-E]{\grR\gamma \vdash C}
  \end{prooftree}
\end{displaymath}

\begin{example}\label{thm:list-rules}
  For lists, we can derive the following introduction and elimination rules
  (with usage constraints in the application of \TirName{$\mu$-E} in the
  \TirName{foldr} rule, relating $\grR$ to $\grP$ and $\grQ$ and restricting
  $\grQ$, omitted to save space).

  \begin{align*}
    \TirName{nil}\left[
    \begin{prooftree}
      \hypo{\grR \leq \gr0}
      \infer1[$I$-I]{\grR\gamma \vdash I}
      \infer1[$\oplus$-I$_0$]%
      {\grR\gamma \vdash I \oplus \plr{A \otimes \mathrm{List}_A}}
      \infer1[$\mu$-I]{\grR\gamma \vdash \mathrm{List}_A}
    \end{prooftree}
    \right.
    &&
    \TirName{cons}\left[
    \begin{prooftree}
      \hypo{\grR \leq \grP + \grQ}
      \hypo{\grP\gamma \vdash A}
      \hypo{\grQ\gamma \vdash \mathrm{List}_A}
      \infer3[$\otimes$-I]{\grR\gamma \vdash A \otimes \mathrm{List}_A}
      \infer1[$\oplus$-I$_1$]%
      {\grR\gamma \vdash I \oplus \plr{A \otimes \mathrm{List}_A}}
      \infer1[$\mu$-I]{\grR\gamma \vdash \mathrm{List}_A}
    \end{prooftree}
    \right.
  \end{align*}
  \begin{displaymath}
    \TirName{foldr}\left[
    \begin{prooftree}
      \hypo{\grP\gamma \vdash \mathrm{List}_A}
      \infer0[Var]{\gr0\gamma, \gr1\plr{I \oplus \plr{A \otimes C}}
        \vdash I \oplus \plr{A \otimes C}}
      \hypo{\nabla^n}
      \hypo{\nabla^c}
      \infer3[$\oplus$-E]{\grQ\gamma, \gr1\plr{I \oplus \plr{A \otimes C}}
        \vdash C}
      \infer2[$\mu$-E]{\grR\gamma \vdash C}
    \end{prooftree}
    \right.
  \end{displaymath}
  \begin{align*}
    \textrm{where }\nabla^n &\coloneqq
    \begin{prooftree}
      \infer0[Var]{\gr0\gamma, \gr1I \vdash I}
      \hypo{\grQ\gamma \vdash C}
      \infer1[Wk]{\grQ\gamma, \gr0I \vdash C}
      \infer2[$I$-E]{\grQ\gamma, \gr1I \vdash C}
      \infer1[Wk]{\grQ\gamma, \gr0\plr{I \oplus \plr{A \otimes C}}, \gr1I
        \vdash C}
    \end{prooftree}
    \\\\
    \textrm{and }\nabla^c &\coloneqq
    \begin{prooftree}
      \infer0[Var]{\gr0\gamma, \gr1\plr{A \otimes C} \vdash A \otimes C}
      \hypo{\grQ\gamma, \gr1A, \gr1C \vdash C}
      \infer1[Wk]{\grQ\gamma, \gr0\plr{A \otimes C}, \gr1A, \gr1C \vdash C}
      \infer2[$\otimes$-E]{\grQ\gamma, \gr1\plr{A \otimes C} \vdash C}
      \infer1[Wk]%
      {\grQ\gamma, \gr0\plr{I \oplus \plr{A \otimes C}}, \gr1\plr{A \otimes C}
        \vdash C}
    \end{prooftree}
  \end{align*}

  Specially for lists, we can note that the \TirName{nil} constructor appears
  exactly once (at the end of a series of \TirName{cons}es) in any value.
  This suggests that we can handle \TirName{nil} linearly when doing recursion
  over lists --- i.e., we do not need to handle the \TirName{nil} constructor in
  a usage context $\grQ$ satisfying $\grQ \leq \gr0$ and
  $\grQ \leq \grQ + \grQ$.

  The key in treating \TirName{nil} linearly is to use \TirName{foldr} with
  endofunction return type $C \multimap C$.
  Such functions let us pass the desired \TirName{nil} value through all of the
  \TirName{cons}es into its required place.
  I give this construction rigorously in the derivation below, which describes
  how to take a list, a \TirName{nil} value $\nabla^n : \grS\gamma \vdash C$,
  and a \TirName{cons} value $\nabla^c : \grQ\gamma, \gr1A, \gr1C \vdash C$ and
  produce a result of type $C$.
  I have omitted side conditions
  $\grR \leq \grP + \grQ$, $\grQ \leq \gr0$, $\grQ \leq \grQ + \grQ$, and
  $\grT \leq \grR + \grS$ in order to save space in the figure.
  I have also omitted subderivation $\mathrm{id}$, constructing the identity
  function (noting that $\grQ \leq \gr0$, and therefore all of the additional
  variables can be discarded), and the details of a use of substitution ---
  labelled \TirName{Subst}.
  I introduce substitution in its full generality in \cref{sec:ren-sub-lr}, but
  the intuitive justification for using substitution here is that we apply the
  variable of type $C \multimap C$ to the variable of type $C$ to produce a
  value of type $C$.
  This uses up both the function and the argument, leaving just a single linear
  value.
  One could also imagine introducing a let-binding, together with weakening of
  $\gr0$-annotated variables, to make the shape of the sequent line up with that
  of $\nabla^c$.

  \begin{displaymath}
    \begin{prooftree}
      \hypo{\grP\gamma \vdash \mathrm{List}_A}
      \hypo{\mathrm{id}}
      \infer[no rule]1{\grQ\gamma \vdash C \multimap C}
      \hypo{\nabla^c}
      \infer[no rule]1{\grQ\gamma, \gr1A, \gr1C \vdash C}
      \infer1[Subst]{\grQ\gamma, \gr1A, \gr1\plr{C \multimap C}, \gr1C \vdash C}
      \infer1[$\multimap$-I]{\grQ\gamma, \gr1A, \gr1\plr{C \multimap C} \vdash C \multimap C}
      \infer3[foldr]{\grR\gamma \vdash C \multimap C}
      \hypo{\nabla^n}
      \infer[no rule]1{\grS\gamma \vdash C}
      \infer2[$\multimap$-E]{\grT\gamma \vdash C}
    \end{prooftree}
  \end{displaymath}

  Given an annotation $\gr r$ satisfying $\gr r \leq \gr0$,
  $\gr r \leq \gr r + \gr r$, and $\gr r \leq 1$ (for example, $\gr\omega$ from
  \cref{def:lin-semiring}), we can produce a function
  \[
    \mathrm{foldr}_{A,C} : \mathrm{List}_A \multimap \oc\gr rC \multimap
    \oc\gr r\plr{A \multimap C \multimap C} \multimap C
  \]
  as a simple wrapping of the \TirName{foldr} rule.
  We can get a function $\mathrm{foldr}_{A,C}'$ as follows using
  $\mathrm{foldr}_{A,C \multimap C}$, and similar reasoning as above to
  treat the \TirName{nil} case linearly.
  I use square brackets to denote the \TirName{$\oc$-I} rule, a pattern
  matching let-expression to denote the \TirName{$\oc$-E} rule, and standard
  $\lambda$-calculus notation for function introduction and elimination.
  \begin{align*}
    \mathrm{foldr}_{A,C}' &: \mathrm{List}_A \multimap C \multimap
    \oc\gr r\plr{A \multimap C \multimap C} \multimap C \\
    \mathrm{foldr}_{A,C}' &\coloneqq \lambda e.\lambda n.\lambda c'.~%
                            \textrm{let }[c] \coloneqq c'\textrm{ in }
                            \mathrm{foldr}_{A,C \multimap C}\,e\,
                            [\lambda r.~r]\,
                            [\lambda x.\lambda f.\lambda r.~c\,x\,(f\,r)]\,
                            n
  \end{align*}
\end{example}

Among the inductive types given by this $\mu$ operator are also
\emph{$\with$-lists} (\emph{with-lists}).

\begin{example}
  Let us define \emph{$\with$-lists} as follows.
  \[
    \mathrm{WithList}_A \coloneqq \mu X.~\top \oplus \plr{A \with X}
  \]
  Unlike ordinary lists (which we may call \emph{$\otimes$-lists}),
  $\with$-lists support a \emph{lookup} operation with the type below, where
  $\mathbb N \coloneqq \mu X.~I \oplus X$.
  \begin{align*}
    \mathit{lookup} :
    \mathrm{WithList}_A \multimap \mathbb N \multimap \top \oplus A
  \end{align*}
  The $\name$ term implementing $\mathit{lookup}$ in terms of iterators
  (\TirName{$\mu$-E}) is complex and tedious, so I do not show it here.
  Instead, I provide the following clausal specification, where
  $\mathrm{nil}\plr{-}$ and $\mathrm{cons}\plr{-}$ are the constructors of
  $\with$-lists, $\mathrm{zero}\plr{}$ and $\mathrm{succ}\plr{}$ are the
  constructors of $\mathbb N$, $\mathrm{inl}\plr{-}$ and $\mathrm{inr}\plr{-}$
  are the constructors of $\oplus$, $\langle\rangle$ constructs the
  inhabitant of $\top$, and postfix $.\pi_l$ and $.\pi_r$ are the projections
  out of a $\with$-pair.

  \[
    \begin{pmboxed}
      \defaultcolumn{l}
      \> \mathit{lookup} \> \mathrm{nil}\plr{t} \> i
      \> \coloneqq \> \mathrm{inl}\plr{\langle\rangle} \\
      \> \mathit{lookup} \> \mathrm{cons}\plr{\mathit{xxs}}
      \> \mathrm{zero}\plr{} \> \coloneqq
      \> \mathrm{inr}\plr{\mathit{xxs}.\pi_l} \\
      \> \mathit{lookup} \> \mathrm{cons}\plr{\mathit{xxs}}
      \> \mathrm{succ}\plr{i} \> \coloneqq
      \> \mathit{lookup}\,\plr{\mathit{xxs}.\pi_r}\,i \\
    \end{pmboxed}
  \]
\end{example}

Following \cref{sec:lnd}, I want to turn the ad hoc constraints on $\grP$,
$\grQ$, and $\grR$ into the result of some premise connectives.
To do this, I introduce a new connective $\Box^{0{+}}$ defined below,
along with the resulting implicit-context typing rules.

\begin{samepage}
  \ExecuteMetaData[\Bunchedtex]{Box}
\end{samepage}

\begin{align*}
  \begin{prooftree}[comb]
    \hypo{\vdash F[\mu X.~F[X]]}
    \infer1[$\mu$-I]{\vdash \mu X.~F[X]}
  \end{prooftree}
  &&
  \begin{prooftree}[comb]
    \hypo{\vdash \mu X.~F[X]}
    \hypo{\sep}
    \hypo{\Box^{0{+}}\plr{\gr1F[C] \vdash C}}
    \infer3[$\mu$-E]{\vdash C}
  \end{prooftree}
\end{align*}

\begin{example}
  We can state the rules for lists derived in \cref{thm:list-rules} as follows.
  \begin{align*}
    \begin{prooftree}[comb]
      \hypo{I^*}
      \infer1{\vdash \mathrm{List}_A}
    \end{prooftree}
    &&
    \begin{prooftree}[comb]
      \hypo{\vdash A}
      \hypo{\sep}
      \hypo{\vdash \mathrm{List}_A}
      \infer3{\vdash \mathrm{List}_A}
    \end{prooftree}
    &&
    \begin{prooftree}[comb]
      \hypo{\vdash \mathrm{List}_A}
      \hypo{\sep}
      \hypo{\Box^{0{+}}
        \plr{\vdash C\hskip0.75em\dottimes\hskip0.75em\gr1A, \gr1C \vdash C}}
      \infer3{\vdash C}
    \end{prooftree}
  \end{align*}
\end{example}

As suggested by the notation, $\Box^{0{+}}$ may not be particularly canonical in
terms of what operations the usage context is stable under.
For example, we could also ask for $\forall \gr r.~\grQ \leq \gr r\grQ$, i.e.\
that the usage context is stable under any scaling.
This would allow us to include $\oc\gr r(-)$ in our grammar of strictly positive
functors.
In certain semirings, this could give us strange types, like, taking the
monotonicity semiring, the type
$\mu X.~I \oplus (\iota \otimes \oc\gr{\downarrow\downarrow} X)$,
which is the type of lists over the base type $\iota$ where alternating elements
are treated contravariantly and covariantly.
This may motivate us to restrict strictly positive functors to allow only a
subset of usage annotations.
Separately, in some contexts we may only need to know that $\grQ \leq \gr0$.
For example, in the linearity semiring, being less than or equal to $\gr0$
happens to imply closure under addition, because the only annotations less than
or equal to $\gr0$ are $\gr0$ and $\gr\omega$.
Also, in semirings for relevant systems, all annotations are stable under
addition (up to $\leq$ in the appropriate direction), so we need only check for
being less than or equal to $\gr0$.

Similar modalities named $\Box$ appear in the work of \citet{BB18} when they
deal with \emph{persistent predicates} in bunched logic, and in the work of
\citet{CK20} in a capability-aware calculus.
Both of these papers, in common with this thesis, aim to pick out the
\emph{pure} or \emph{safe} objects, i.e.\ those not depending on any external
resources.
