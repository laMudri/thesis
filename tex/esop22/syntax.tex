\subsection{A prototypical type system}

\begin{figure}
  \begin{displaymath}
    \begin{prooftree}[comb]
      \hypo{\sqni A}
      \infer1[Var]{\vdash A}
    \end{prooftree}
    \qquad
    \begin{prooftree}[comb]
      \hypo{\gr1A \vdash B}
      \infer1[$\multimap$-I]{\vdash A \multimap B}
    \end{prooftree}
    \qquad
    \begin{prooftree}[comb]
      \hypo{\vdash A \multimap B}
      \hypo{\sep}
      \hypo{\vdash A}
      \infer3[$\multimap$-E]{\vdash B}
    \end{prooftree}
  \end{displaymath}
  \begin{displaymath}
    \begin{prooftree}[comb]
      \hypo{\vdash A_i}
      \infer1[$\oplus$-I$_i$]{\vdash A_0 \oplus A_1}
    \end{prooftree}
    \qquad
    \begin{prooftree}[comb]
      \hypo{\vdash A \oplus B}
      \hypo{\sep}
      \hypo{(\gr1A \vdash C}
      \hypo{\dottimes}
      \hypo{\gr1B \vdash C)}
      \infer5[$\oplus$-E]{\vdash C}
    \end{prooftree}
  \end{displaymath}
  \begin{displaymath}
    \begin{prooftree}[comb]
      \hypo{\gr r \cdot \plr{\vdash A}}
      \infer1[$\oc_{\gr r}$-I]{\vdash \oc_{\gr r} A}
    \end{prooftree}
    \qquad
    \begin{prooftree}[comb]
      \hypo{\vdash \oc_{\gr r} A}
      \hypo{\sep}
      \hypo{\gr rA \vdash C}
      \infer3[$\oc_{\gr r}$-E]{\vdash C}
    \end{prooftree}
  \end{displaymath}
  \caption{\cref{fig:lr} restated in terms of bunched combinators}
  \label{fig:lr-comb}
\end{figure}

\subsection{Descriptions}

We capture the form of rules exemplified previously\todo{Previously?} via
\emph{descriptions} of rules.
The key to making these descriptions work is that they only allow syntactic
forms that preserve environments.
These forms are: absence and multiplicity of subterms with the same usage
annotations, absence and multiplicity of subterms with summed usage annotations,
scaling of a subterm, and variable binding.

A type \AgdaRecord{System} is made up of multiple \AgdaRecord{Rule}s.
Each \AgdaRecord{Rule} comprises a tree of \AgdaDatatype{Premises} and a type
of conclusion.

A single premise is introduced by the
\AgdaInductiveConstructor{$\langle$\_`$\vdash$\_$\rangle$} constructor.
This allows binding of some variables \AgdaBound{$\Delta$} (with specified
types and usage annotations) and the specification of a conclusion type
\AgdaBound{A}.
The rest of the constructors are descriptions for the first-order bunched
connectives, and are interpreted directly as such.

\ExecuteMetaData[\Syntaxtex]{Premises}
\ExecuteMetaData[\Syntaxtex]{Rule}
\ExecuteMetaData[\Syntaxtex]{System}

As an example, we transcribe the system defined in \cref{fig:lr-comb} into a
description.
We first give the set of types in a standard way (together with base type
\AgdaInductiveConstructor{$\iota$}).

\ExecuteMetaData[\PaperExamplestex]{Ty}

%Then, we give the set of labels.
There is one label for each instantiation of a logical rule, but the labels
contain no further information about subterms or restrictions on the context.

\ExecuteMetaData[\PaperExamplestex]{qlR}

Finally, we specify, for each label, the rest of the information about that
rule {\color{red}(premises and conclusion)}.
We do not have a variable rule, because the variable rule is implicit to any
type system.
{\color{red}(Looks like \cref{fig:lr-comb})}

\ExecuteMetaData[\PaperExamplestex]{lR}

The next thing we want to do is to build terms in the described type system.

\ExecuteMetaData[\Syntaxtex]{OpenFam}

To specify the meaning of descriptions, we assume some
\ExecuteMetaData[\Interpretationtex]{X}, over which we form one layer of syntax.
The first argument to \AgdaBound{X} is the new variables bound by this layer
of syntax, as exemplified in the first clause of
\AgdaFunction{$\llbracket$\_$\rrbracket$p}.
The second argument is the context containing the variables being carried over
from the previous layer.
Notice that this is not, in general, the same as the context from the previous
layer, because the usage annotations may have been changed by connectives like
\AgdaInductiveConstructor{\_`$*$\_} and \AgdaInductiveConstructor{\_`$\cdot$\_}.
The third argument is the type of subterm required.

With the first clause of \AgdaFunction{$\llbracket$\_$\rrbracket$p} explained,
the rest are simply interpretations into bunched combinators.

\ExecuteMetaData[\Interpretationtex]{semp}

The interpretation of a \AgdaRecord{Rule} is to check that the rule targets
the desired type and then interpret the rules premises \AgdaBound{ps}.
Notice that the interpretation of the premises is independent of the conclusion
of the rule, which accounts for the difference in type between
\AgdaFunction{$\llbracket$\_$\rrbracket$p} and
\AgdaFunction{$\llbracket$\_$\rrbracket$r}.

\ExecuteMetaData[\Interpretationtex]{semr}

The interpretation of a \AgdaRecord{System} is to choose a rule label
\AgdaBound{l} from \AgdaBound{L} and interpret the corresponding rule
\AgdaBound{rs}\AgdaSpace{}\AgdaBound{l} in the same context and for the same
conclusion.

\ExecuteMetaData[\Interpretationtex]{sems}

The most obvious way to make such an \AgdaBound{X} is to use some existing
\AgdaFunction{OpenFam} on an extended context.
This is what \AgdaFunction{Scope} does --- take the new variables
\AgdaBound{$\Delta$}, concatenate them onto the existing context
\AgdaBound{$\Gamma$}, and pass the extended context onto the judgement
\AgdaBound{T}.

\ExecuteMetaData[\Syntaxtex]{Scope}

{\color{red}(Forward ref: for now, we could have inlined \texttt{Scope}.)}

It is this method we use to deal with new variables in syntax.
Terms resemble the free monad over a layer-of-syntax functor, though that
picture is complicated by variable binding.
A term is either a variable or a use of a logical rule together with terms
for each of the required subterms.

\ExecuteMetaData[\Termtex]{Term}

Here is an example term, using the \AgdaFunction{$\lambda$R} system.
First, for ease of writing, we introduce pattern synonyms for each of the
typing rules we use.

\ExecuteMetaData[\PaperExamplestex]{patterns}

Our example term is a function that flips a tagged union wrapped in an
arbitrarily annotated \emph{bang}.
Much of the effort in writing such a term goes into writing the various
relatedness proofs between usage contexts --- observing, for example, that two
usage contexts sum together to make a third, or that a usage context used for
a variable is a basis vector.
We give a method of automating these proofs in \cref{sec:usage-elaborator}.
\todo{To be clear, we don't actually write this.}

\ExecuteMetaData[\HeavyItex]{lR-term}

A layer of syntax supports the following functorial action.
{\color{red}(Maybe this has to go later, because it talks about linear maps.)}

\ExecuteMetaData[\Maptex]{map-s-type}

\subsection{Other syntaxes}

We can encode a usage-annotated version of System $L$/the
$\mu\tilde\mu$-calculus~\cite{CH00} --- a syntax for classical logic --- in
such a way that contexts capture the undistinguished parts of the sequent.
As such, the generic substitution lemma we get in \cref{sec:kits} is the form
of substitution required in standard $\mu\tilde\mu$-calculus metatheory.
Though the $\mu\tilde\mu$-calculus is originally described as a sequent
calculus~\cite{CH00}, we use the techniques of
\citet[p.~12]{herbelin-hab} and \citet{LC06} to present it as a natural
deduction system, thus giving a notion of \emph{variable} to the system.

Unlike the single judgement form of \name{} and standard simply typed
$\lambda$-calculi, the $\mu\tilde\mu$-calculus has three judgement forms:
terms, coterms, and commands.
Read logically, terms and coterms are seen to, respectively, prove and refute
propositions (types), while commands exhibit contradictions.
This means that the abstract \AgdaBound{Ty} in the generic framework is
instantiated to \AgdaDatatype{Conc} (for \emph{conclusion}) as below, with
\AgdaDatatype{Ty} not being exposed directly to the generic framework.
For now, we just consider multiplicative disjunction $\parr$ (\emph{par}) and
negation/duality, beside an uninterpreted base type.
These are enough to exhibit classical behaviour.

\begin{minipage}[t]{0.5\textwidth}
  \centering
  \ExecuteMetaData[\MuMuTildetex]{Ty}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
  \centering
  \ExecuteMetaData[\MuMuTildetex]{Conc}
\end{minipage}

With \AgdaBound{Ty} instantiated as \AgdaDatatype{Conc}, all terms are assigned
\AgdaDatatype{Conc} type, as are all the variables.
No variables are given \AgdaInductiveConstructor{com} type, similar to how in
the bidirectional typing syntax of \citet[p.~25]{AACMM20}, no variables are
given \AgdaInductiveConstructor{Check} type.
How to observe this invariant is covered in the latter paper, so we will not
repeat it here (having not yet seen how to write traverals on terms).

The syntax comprises a \emph{cut} between a term and a coterm of the same type,
the eponymous $\mu$ and $\tilde\mu$ constructs for proof by contradiction, and
then term and coterm (introduction and elimination) forms for negation and
\emph{par}.

\ExecuteMetaData[\MuMuTildetex]{MMT}

With a collection of pattern synonyms and the machinery from
\cref{sec:usage-elaborator}, we can write an example term: a function which
flips the disjuncts of a \emph{par}.

\ExecuteMetaData[\MuMuTildeTermtex]{patterns}
\ExecuteMetaData[\MuMuTildeTermtex]{myComm}
