\paragraph{New explanation}
Recalling from \cref{sec:kits}, we have the following definition of
\emph{environments} for simple types.

\begin{definition}[Simple environment]
  A $\V$-\emph{environment} between simply typed contexts $\Gamma$ and $\Delta$
  is a function, polymorphic in type $A$, from variables of type $A$ in
  $\Delta$ to inhabitants of $\V\,\Gamma\,A$.
  We write the type of such environments as $\Gamma \env\V \Delta$.
\end{definition}

\begin{definition}[Simple recursive environment]
  A \emph{recursive $\V$-environment} between simply typed contexts $\Gamma$ and
  $\Delta$ is defined by cases on the shape of $\Delta$ (where
  $\Gamma \env\V_R \Delta$ is the notation for the type of recursive
  environments for given $\V$, $\Gamma$, and $\Delta$):
  \begin{itemize}
    \item If $\Delta$ is empty, then there is one environment.
    \item If $\Delta$ is a concatenation $\Delta_l, \Delta_r$, then an
      environment is a pair of environments of types
      $\Gamma \env\V_R \Delta_l$ and $\Gamma \env\V_R \Delta_r$.
    \item If $\Delta$ is a singleton $A$, then an environment is a value of
      type $\V\,\Gamma\,A$.
  \end{itemize}
\end{definition}

\begin{definition}[Usage-annotated recursive environment]
  A \emph{recursive $\V$-environment} between annotated contexts $\Gamma$ and
  $\Delta$ is defined by cases on the shape of $\Delta$ (where
  $\Gamma = \grP\gamma$ and $\Gamma \env\V_R \Delta$ is the notation for the
  type of recursive environments for given $\V$, $\Gamma$, and $\Delta$):
  \begin{itemize}
    \item If $\Delta$ is empty, then an environment exists if $\grP = \gr0$.
    \item If $\Delta$ is a concatenation $\Delta_l, \Delta_r$, then an
      environment is a choice of usage vectors $\grPl$ and $\grPr$ such that
      $\grP = \grPl + \grPr$ and we have a pair of environments of types
      $\grPl\gamma \env\V_R \Delta_l$ and $\grPr\gamma \env\V_R \Delta_r$.
    \item If $\Delta$ is a singleton $\gr rA$, then an environment is a choice
      of a usage vector $\grPprime$ such that $\grP = \gr r\grPprime$ and we
      have a value of type $\V\,\grPprime\gamma\,A$.
  \end{itemize}
\end{definition}

From this definition, we can recover a functional-style definition by
separating choices of usage vectors from the provision of $\V$-values.
In particular, the only choices of usage vectors that are essential are the
$\grPprime$s in the singleton case, with the choices in the concatenation case
being determined as scalings and sums of these $\grPprime$s.
I let $\gr\Psi$ collect up these $\size\Delta$-many choices of
$\size\Gamma$-length usage vectors and note that the constraint on $\gr\Psi$
generated by all the scaling and summing is
$\grP = \sum_{\plr{x : \gr rA} \in \Delta} \gr r\gr\Psi_x$.

\begin{definition}[Usage-annotated environment (tentative)]
  A \emph{$\V$-environment} between annotated contexts $\Gamma$ and $\Delta$
  (written $\grP\gamma$ and $\grQ\delta$, respectively, when convenient)
  is a matrix $\gr\Psi : \Ann^{\size\Delta \times \size\Gamma}$ such that
  $\grP = \sum_{\plr{x : \gr rA} \in \Delta} \gr r\gr\Psi_x$ and for each
  $\plr{x : A} \in \delta$ we have a value of type $\V\,\gr\Psi_x\gamma\,A$.
\end{definition}

We may note, further, that the constraint
$\grP = \sum_{\plr{x : \gr rA} \in \Delta} \gr r\gr\Psi_x$ can be stated as the
vector-matrix multiplication $\grP = \grQ\gr\Psi$.
Using the same operation, we have that $\gr\Psi_x = \langle x \rvert\gr\Psi$.
Because $\langle x \rvert$ is exactly the $\grQprime$ such that
$\plr{x : A} \sqin \grQprime\delta$, we can rephrase the function producing
$\V$-values as: for each $A$, $\grPprime$, and $\grQprime$ such that
$\grPprime = \grQprime\gr\Psi$, a function from $\grQprime\delta \sqni A$ to
$\V\,\grPprime\gamma\,A$.
Finally, I choose to switch from matrices and matrix multiplication to
linear maps and their actions, which are easier to work with.
All of these changes yield my primary definition of an environment for
usage-annotated calculi.

\begin{definition}[Usage-annotated environment]
  A \emph{$\V$-environment} between annotated contexts $\Gamma$ and $\Delta$
  (written $\grP\gamma$ and $\grQ\delta$, respectively, when convenient)
  is a linear map $\gr\Psi : \Ann^{\size\Delta} \to \Ann^{\size\Gamma}$ (written
  postfix) such that $\grP = \grQ\gr\Psi$ and for each $A$, $\grPprime$, and
  $\grQprime$ such that $\grPprime = \grQprime\gr\Psi$, a function from
  $\grQprime\delta \sqni A$ to $\V\,\grPprime\gamma\,A$.
\end{definition}

\paragraph{Old explanation}
As we discussed in \cref{sec:kits}, simultaneous substitution gives a
notion of derivability of one context from another, while simultaneous renaming
gives a similar notion of derivability restricted to structural rules.
To adapt these notions from an intuitionistic setting to our substructural
setting, we must examine what it means to derive one context from another
substructually.

In the intuitionistic case, we say that to derive a context $\Delta$ from a
context $\Gamma$ is to derive each element $\Delta_i$ from $\Gamma$.
We may justify this by an intermediate step --- noting that contexts are
understood to be Cartesian products of their elements, and giving a map into
a Cartesian product is the same as giving a map into each factor.
I picture this definition as the diagram below.

\begin{displaymath}
  \begin{tikzpicture}[baseline]
    \path
    (-1,1) node (Gtop) {}
    (-1,0) node (G) {$\Gamma$}
    (-1,-1) node (Gbot) {}
    ;
    \node[draw,dotted,fit=(Gtop) (G) (Gbot)] (GG) {};

    \path
    (1,1) node (Dtop) {}
    (1,0) node (D) {$\Delta$}
    (1,-1) node (Dbot) {}
    ;
    \node[draw,dotted,fit=(Dtop) (D) (Dbot)] (DD) {};

    \draw[->,double] (GG) -- (DD);
  \end{tikzpicture}
  \coloneqq
  \begin{tikzpicture}[baseline]
    \path
    (-1,1) node (Gtop) {}
    (-1,0) node (G) {$\Gamma$}
    (-1,-1) node (Gbot) {}
    ;
    \node[draw,dotted,fit=(Gtop) (G) (Gbot)] (GG) {};

    \path
    (1,1) node[draw] (Dtop) {$\Delta_1$}
    (1,0) node (D) {$\vdots$}
    (1,-1) node[draw] (Dbot) {$\Delta_n$}
    ;

    \fill[green!20!white,opacity=1] (GG.north east)
    parabola[bend at end] (Dtop.west)
    parabola[bend at start] (GG.south east)
    -- cycle;
    \fill[blue!40!white,opacity=.5] (GG.north east)
    parabola[bend at end] (Dbot.west)
    parabola[bend at start] (GG.south east)
    -- cycle;

    \draw[->] (GG.north east) parabola[bend at end] (Dtop.west);
    \draw (GG.south east) parabola[bend at end] (Dtop.west);
    \draw[->] (GG.north east) parabola[bend at end] (D.west);
    \draw (GG.south east) parabola[bend at end] (D.west);
    \draw[->] (GG.north east) parabola[bend at end] (Dbot.west);
    \draw (GG.south east) parabola[bend at end] (Dbot.west);
  \end{tikzpicture}
\end{displaymath}

To see how this definition works, let us construct an example substitution:
$A, B \to C, B \Longrightarrow B, C$.
Because the codomain is a Cartesian product, it suffices to give two separate
substitutions, $A, B \to C, B \Longrightarrow B$ and
$A, B \to C, B \Longrightarrow C$, with a substitution into a singleton
context being just a term.
We indeed have terms $x : A, y : B \to C, z : B \vdash y : B$ and
$x : A, y : B \to C, z : B \vdash y\,z : C$.
It is also instructive to look at an identity substitution (which is also a
renaming), $A, B \Longrightarrow A, B$, witnessed by terms
$x : A, y : B \vdash x : A$ and $x : A, y : B \vdash y : B$.

When working with our semiring-annotated calculus \name{}, contexts are no
longer understood as Cartesian products.
This means that substitutions of type $\Gamma \Longrightarrow \Delta$ are no
longer equivalent to collections of substitutions
$\Gamma \Longrightarrow \Delta_i$.
Indeed, notice that we should still have an identity substitution of type
$\gr1A, \gr1B \Longrightarrow \gr1A, \gr1B$, but we do not have terms proving
either $\gr1A, \gr1B \vdash A$ or $\gr1A, \gr1B \vdash B$.
What we do have are terms $x : \gr1A, y : \gr0B \vdash x : A$ and
$x : \gr0A, y : \gr1B \vdash y : B$, and if we pointwise add together the
annotations of the two terms, we get back the original context
$x : \gr1A, y : \gr1B$.
Furthermore, adding up the annotations is not just a random operation;
linear contexts are understood to be tensor products of their elements, and
introduction rule for the tensor product involves summing the annotations of
the two sides.

For any annotated context $\Delta$, we have
$\Delta \vdash \bigotimes_{(\gr rx : A) \in \Delta}\oc\gr rA$ by iterated
application of $\otimes$-I with $\oc$-I and Var at the leaves.
Let $\Gamma = \grP\gamma$ and $\Delta = \grQ\delta$.
If we are to produce substitutions from $\Gamma$ to $\Delta$ in this
pattern, we simulate the applications of $\otimes$-I by producing, for each
element in $\Delta$, a usage context for $\gamma$ such that the whole collection
sums to $\grP$, then simulate the applications of $\oc$-I by dividing each of
the new usage contexts by the corresponding annotation in $\Delta$, calling
the divided usage contexts $\gr\Psi_x$, and finally, instead of a variable
from $\delta$, we give a term of type $\gr\Psi_x\gamma \vdash \delta_x$.
In summary, the constraint on the collection of usage contexts $\gr\Psi$ is
that $\grP = \sum_{(\gr rx : A) \in \Delta}\gr r\gr\Psi_x$.
Moreover, if we take $\grP$ and $\grQ$ to be row vectors and $\gr\Psi$ to be a
matrix, the latter expression is equal to the vector-matrix multiplication
$\grQ\gr\Psi$.
The resulting definition of simultaneous substitution is depicted below.

\begin{displaymath}
  \begin{tikzpicture}[baseline]
    \path
    (-1,1) node (Gtop) {}
    (-1,0) node (G) {$\grP\gamma$}
    (-1,-1) node (Gbot) {}
    ;
    \node[draw,dotted,fit=(Gtop) (G) (Gbot)] (GG) {};

    \path
    (1,1) node (Dtop) {}
    (1,0) node (D) {$\grQ\delta$}
    (1,-1) node (Dbot) {}
    ;
    \node[draw,dotted,fit=(Dtop) (D) (Dbot)] (DD) {};

    \draw[->,double] (GG) -- (DD);
  \end{tikzpicture}
  \coloneqq
  \begin{tikzpicture}[baseline]
    \path
    (-1,1) node (Gtop) {}
    (-1,0) node (G) {$\grP\gamma$}
    (-1,-1) node (Gbot) {}
    ;
    \node[draw,dotted,fit=(Gtop) (G) (Gbot)] (GG) {};

    \path
    (1,3) node (G1top) {}
    (1,2) node (G1) {$\gr\Psi_1\gamma$}
    (1,1) node (G1bot) {}
    ;
    \node[draw,dotted,fit=(G1top) (G1) (G1bot)] (GG1) {};
    \draw[->] (GG) -- (GG1);

    \path (1,0) node {$\vdots$};

    \path
    (1,-1) node (Gntop) {}
    (1,-2) node (Gn) {$\gr\Psi_n\gamma$}
    (1,-3) node (Gnbot) {}
    ;
    \node[draw,dotted,fit=(Gntop) (Gn) (Gnbot)] (GGn) {};
    \draw[->] (GG) -- (GGn);

    \path
    (3,1) node[draw] (Dtop) {$\delta_1$}
    (3,0) node (D) {$\vdots$}
    (3,-1) node[draw] (Dbot) {$\delta_n$}
    ;

    \fill[green!20!white] (GG1.north east)
    parabola[bend at end] (Dtop.west)
    parabola[bend at start] (GG1.south east)
    -- cycle;
    \draw[->] (GG1.north east) parabola[bend at end] (Dtop.west);
    \draw (GG1.south east) parabola[bend at end] (Dtop.west);

    \fill[blue!20!white] (GGn.north east)
    parabola[bend at end] (Dbot.west)
    parabola[bend at start] (GGn.south east)
    -- cycle;
    \draw[->] (GGn.north east) parabola[bend at end] (Dbot.west);
    \draw (GGn.south east) parabola[bend at end] (Dbot.west);
  \end{tikzpicture}
  \quad\textrm{where }\grP = \grQ\gr\Psi
\end{displaymath}

In type theory, we write out the definition as follows.

\begin{displaymath}
  \sum_{\gr\Psi : \size\Delta \to \size\Gamma \to \Ann}
    \left(\grP = \grQ\gr\Psi\right) \times
    \prod_{(x : A) \in \delta}\gr\Psi_x\gamma \vdash A
\end{displaymath}

We can see the step-by-step construction of a substitution play out by adapting
the previous example to have type
$\gr0A, \gr2(B \multimap C), \gr3B \Longrightarrow \gr1B, \gr2C$.
To split the goal up, we note that $
\begin{pmatrix} \gr0 & \gr2 & \gr3 \end{pmatrix} =
\begin{pmatrix} \gr0 & \gr0 & \gr1 \end{pmatrix} +
\begin{pmatrix} \gr0 & \gr2 & \gr2 \end{pmatrix}
$, so it suffices to give substitutions of types
$\gr0A, \gr0(B \multimap C), \gr1B \Longrightarrow \gr1B$ and
$\gr0A, \gr2(B \multimap C), \gr2B \Longrightarrow \gr2C$.
Furthermore, our term calculus only supports $\gr1$-annotated conclusions,
so we divide the second substitution type through by $\gr2$.
Finally, we give the terms largely as before:
$\gr0x : A, \gr0y : B \to C, \gr1z : B \vdash y : B$ and
$\gr0x : A, \gr1y : B \to C, \gr1z : B \vdash z\,y : C$.

While we naturally derive a matrix as a fragmentation of a usage vector, we can
get a slightly cleaner presentation by instead using an abstract linear map.
Let $\gr\Psi$ now be a linear map of type
$\Ann^{\size\Delta} \to \Ann^{\size\Gamma}$, with application written postfix.
The equation $\grP = \grQ\gr\Psi$ remains unchanged.
Where we previously wrote $\gr\Psi_x$, the most direct replacement would be
$\langle x \rvert\gr\Psi$, with $\langle x \rvert$ being the $x$th basis row
vector.
But then we notice that $\langle x \rvert$ is exactly the $\grQprime$ satisfying
$\grQprime\delta \sqni x : B$.
This gives us the following definition, which can be verified by equationally
substituting $\grPprime$ and expanding the definition of $\sqni$.

\begin{displaymath}
  \sum_{\gr\Psi : \Ann^{\size\Delta} \to \Ann^{\size\Gamma}}
    \left(\grP = \grQ\gr\Psi\right) \times
    \prod_{A,\grQprime,\grPprime} \left(
    \grPprime = \grQprime\gr\Psi \to \grQprime\delta \sqni A \to
    \grPprime\gamma \vdash A\right)
\end{displaymath}

We now have a new reading for the interpretation of a linear substitution:
a linear map $\gr\Psi$ relating the two usage vectors $\grP$ and $\grQ$, and
for any two similarly related usage vectors $\grPprime$ and $\grQprime$, we
have a type-preserving function from variables in $\grQprime\delta$ to terms in
$\grPprime\gamma$.
Even though we don't use $\gr\Psi$ as a matrix containing fragmented usage
vectors, we can still justify why it should be a \emph{linear} map.
We need $\gr\Phi$ to respect all fragmentation of the usage context in a typing
rule, and we know that all such fragmentation is done by linear operations
zero, addition, and scaling by a constant.
\todo{Expand. Substitutions need to preserve everything done to the context,
and linear things are all we do to the context.}

Taking a lead from \cref{sec:kits}, we deduce a definition of
\emph{environment} by replacing the $\vdash$ in the definition of simultaneous
substitution by an arbitrary type family $\mathcal V$.
Letting $\mathcal V$ be $\sqni$ gives us a notion of simultaneous renaming,
allowing for renamings with types such as
$\gr6A, \gr0B, \gr1C \stackrel\sqni\Longrightarrow \gr1C, \gr2A, \gr4A$.

It is worth noting that, when contexts are Cartesian products, passing from
``a map into $\Delta$'' to ``for each $A \in \Delta$, a map into $A$'' does not
lose any generality because the universal property of Cartesian products
states that every map into a Cartesian product can be given factor-wise.
Hence, $\Delta$ and the one-element context $\prod_{A \in \Delta}A$ are
isomorphic in the category of contexts and simultaneous substitution.
However, tensor products are not limits, so don't have the same universal
property.
Indeed, many annotated contexts are not isomorphic to the weighted product of
their elements.
For example, we do not have a substitution of type
$\gr1(A \otimes B) \Longrightarrow \gr1A, \gr1B$ because we would first need
to pattern-match on the tensor product \emph{before} trying to derive the
target context.
This loss of generality is however justified when we consider the action of a
substitution.
Substitutions should only be replacing variables by terms, whereas if
substitutions were allowed to pattern-match before introducing the target, then
the substitution would have to replace the original term by a term that first
pattern-matches and then continues like the original term.
